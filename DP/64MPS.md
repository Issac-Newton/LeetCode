前两天看了一些关于动态规划的文章，对动态规划背后的思想认知逐渐丰满起来。学习是一个循序渐进的过程，通过一两道题就想把动态规划这种算法（暂且称它是一种算法吧）运用的特别熟练，这是不现实的。在了解算法思想的基础上，通过做题进行实践，得到自己对算法的认知，之后再通过自己的认知指导实践的完成。正如**马克思**所说，对具体事物的认识需要经过两次飞跃：实践到认知以及由认识到实践，还要经过多次反复。

这道题目给定一个非负矩阵，需要找到一条从左上角到右下角经过路径使得路径上面的数字的和最小，当然，每一步只能向右或者向下走。

这里用F(m,n)表示从（1，1）走到（m,n）位置的最小路径的和,K(m,n)表示矩阵相应位置的数。可以推出，F(m,n) = min{F(m-1,n),F(m,n-1)}+K(m,n)。前几天做过的题目中提到的一种优化方法可以让存储小一些。具体代码如下：

```
	int minPathSum(vector<vector<int>>& grid) {
        if(grid.empty() || grid[0].empty()) return 0;
        int r = grid.size(),l = grid[0].size();
        
        vector<long> dp(l,0);
        
        for(int i = 0;i < r;i++){
            for(int j = 0;j < l;j++){
                if(j == 0) dp[j] += grid[i][j];
                else if(i == 0) dp[j] = dp[j-1] + grid[i][j];
                else dp[j] = min(dp[j],dp[j-1]) + grid[i][j];
            }
        }
        return dp[l-1];
    }
```